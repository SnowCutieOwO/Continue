import{_ as a,c as s,o as i,b0 as n}from"./chunks/framework.w6NQj85O.js";const c=JSON.parse('{"title":"背包保存","description":"","frontmatter":{},"headers":[],"relativePath":"HuskSync/guides.keep-inventory.md","filePath":"HuskSync/guides.keep-inventory.md"}'),t={name:"HuskSync/guides.keep-inventory.md"};function l(h,e,o,p,r,d){return i(),s("div",null,e[0]||(e[0]=[n(`<h1 id="背包保存" tabindex="-1">背包保存 <a class="header-anchor" href="#背包保存" aria-label="Permalink to &quot;背包保存&quot;">​</a></h1><p>若你的服务器使用了 <code>keepInventory</code>，一种让玩家在死后保留背包物品的规则，HuskSync 内置的死亡快照和死亡玩家背包同步功能可能导致同步问题。</p><p>若要解决此问题，你需要修改配置文本 <code>config.yml</code> 的内容，如下文所示。</p><h2 id="为什么会这样" tabindex="-1">为什么会这样？ <a class="header-anchor" href="#为什么会这样" aria-label="Permalink to &quot;为什么会这样？&quot;">​</a></h2><p>HuskSync 在玩家死亡时有特殊处理，以应对玩家死后切换服务器的情况（防止物品丢失）。</p><ul><li>死亡状态保存——HuskSync 有特殊的逻辑保存玩家数据快照，<em>除了</em>他们切换服务器时的<em>背包内容</em>。当 <a href="https://zh.minecraft.wiki/w/%E6%B8%B8%E6%88%8F%E8%A7%84%E5%88%99" target="_blank" rel="noreferrer"><code>keepInventory</code> 游戏规则</a>启用时，背包栏仍然保存着物品，所以快照不会正确保存。该逻辑是默认启用的；</li><li>死亡时创建快照—HuskSync 在玩家死亡时会创建一个用于备份的特殊快照，拿走他们的掉落物并将它们重新放回玩家的背包。当 <code>keepInventory</code> 启用时，玩家不会掉落物品，所以这会导致不正确的快照被创建。该功能默认启用。</li></ul><h2 id="这要如何修复" tabindex="-1">这要如何修复？ <a class="header-anchor" href="#这要如何修复" aria-label="Permalink to &quot;这要如何修复？&quot;">​</a></h2><p>你需要将 <code>config.yml</code> 中的 <code>synchronization.save_on_death</code>（控制是否在死亡时生成快照）、<code>save_empty_drops_on_death</code>（控制空背包的玩家是否在死亡时产生快照）和 <code>synchronization.synchronise_dead_players_changing_server</code>（控制切换服务器时是否同步死亡玩家的背包）项设置为 <code>false</code>。</p><h3 id="config-yml-中的示例" tabindex="-1">config.yml 中的示例 <a class="header-anchor" href="#config-yml-中的示例" aria-label="Permalink to &quot;config.yml 中的示例&quot;">​</a></h3><div class="language-YAML vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">YAML</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">synchronization</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    # ...</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">    save_on_death</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> # &lt;-- 将这个设置为 false</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">    save_empty_drops_on_death</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> # &lt;-- 将这个设置为 false</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    # ...</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">    synchronise_dead_players_changing_server</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> # &lt;-- 将这个设置为 false</span></span></code></pre></div><h2 id="通过自定义-keepinventory-设置排除问题" tabindex="-1">通过自定义 keepInventory 设置排除问题 <a class="header-anchor" href="#通过自定义-keepinventory-设置排除问题" aria-label="Permalink to &quot;通过自定义 keepInventory 设置排除问题&quot;">​</a></h2><p>若上述的操作方法对你均无效，你可能需要再做一些额外的事情才能让它正确工作。</p><p>若你的服务器使用了高级的设置，例如只保留物品，其他不受插件逻辑影响，那么你需要使用 HuskSync API 来创建一个联动来更新 DataSaveEvent 事件上的数据，以此解决<em>死亡玩家</em>切换服务器所产生的问题.</p><p>若你的服务器使用了一个权限节点来控制死亡的物品保存，你应该能按照上述步骤正常设置，方法可能据服务器的设置方式和处理玩家的不同方式而略有区别。请注意这个选项可能也会和其他试图保存物品的插件冲突。</p>`,14)]))}const y=a(t,[["render",l]]);export{c as __pageData,y as default};
