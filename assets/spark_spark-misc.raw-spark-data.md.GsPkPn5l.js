import{_ as a,c as i,o as t,b0 as e}from"./chunks/framework.w6NQj85O.js";const d=JSON.parse('{"title":"spark 的原数据","description":"","frontmatter":{},"headers":[],"relativePath":"spark/spark-misc.raw-spark-data.md","filePath":"spark/spark-misc.raw-spark-data.md"}'),p={name:"spark/spark-misc.raw-spark-data.md"};function n(l,s,h,r,k,o){return t(),i("div",null,s[0]||(s[0]=[e(`<h1 id="spark-的原数据" tabindex="-1">spark 的原数据 <a class="header-anchor" href="#spark-的原数据" aria-label="Permalink to &quot;spark 的原数据&quot;">​</a></h1><p>有些人可能需要用到 spark 获取的原数据，通常用于对接机器人或其他用途。本章节将会详细讲述如何获取这些东西。😎</p><h2 id="json" tabindex="-1">JSON <a class="header-anchor" href="#json" aria-label="Permalink to &quot;JSON&quot;">​</a></h2><p>假设你有一个 spark 报告链接：<code>https://spark.lucko.me/abc123</code></p><p>收集本次会话的原始数据最直接的方法就是在链接末尾加上 <code>?raw=1</code> 参数并对其发送 HTTP 请求：</p><div class="language-HTTP vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">HTTP</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">GET</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> https://spark.lucko.me/abc123?raw=1</span></span></code></pre></div><p>你应该会得到一个类似下文的 JSON 结构文本：</p><div class="language-JSON vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">JSON</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;metadata&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    &quot;user&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">      &quot;type&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">      &quot;name&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Luck&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">      &quot;uniqueId&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;c1d60c50-70b5-4722-8057-87767557e50d&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    },</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    &quot;startTime&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1678186955567</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 诸如此类...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>你也可以在参数末尾添加诸如 <code>&amp;path=some.jsonpath.here</code> 等内容按 <a href="https://github.com/json-path/JsonPath" target="_blank" rel="noreferrer">JSON 路径</a>进行过滤。</p><div class="language-HTTP vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">HTTP</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">GET</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> https://spark.lucko.me/abc123?raw=1&amp;path=metadata.platform</span></span></code></pre></div><div class="language-JSON vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">JSON</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;type&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;name&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Bukkit&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;version&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;git-Paper-386 (MC: 1.19.3)&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;minecraftVersion&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;1.19.3&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;sparkVersion&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><div class="info custom-block"><p class="custom-block-title">注意</p><p>默认情况下，这些节点只会返回与会话有关的<strong>元数据</strong>。大多数情况下这是够用的。<br> 但是如果你真的想要抽样/堆转储数据，首先，你可以自己下载/判断<strong>原</strong>数据。能省我很多事！（详见下文）<br> 如果不行，你也可以在链接末尾加上参数 <code>&amp;full=true</code> 来使其返回<strong>完整</strong>内容，但是要注意，这可能会让获取的 JSON 大小达到 MB 级别，从而导致读取困难！</p></div><h2 id="原数据" tabindex="-1">原数据 <a class="header-anchor" href="#原数据" aria-label="Permalink to &quot;原数据&quot;">​</a></h2><p>spark 所使用的存储服务称作 <a href="https://github.com/lucko/bytebin" target="_blank" rel="noreferrer">bytebin</a> spark 所使用的指定接口为 <a href="https://spark-usercontent.lucko.me/" target="_blank" rel="noreferrer">https://spark-usercontent.lucko.me/</a></p><p>若要收集指定报告中的原数据（如 <code>https://spark.lucko.me/abc123/</code>），需要向用户内容端发送一个 GET 的 HTTPS 请求：</p><div class="language-HTTP vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">HTTP</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">GET</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> https://spark-usercontent.lucko.me/abc123</span></span></code></pre></div><p>若成功发送，则你会收到一个类似下文的信息：</p><div class="language-HTTP vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">HTTP</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">HTTP/2 </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">200</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Content-Type</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> application/x-spark-sampler</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Last-Modified</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> Tue, 07 Mar 2023 13:16:44 GMT</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Cache-Control</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> public, max-age=604800, no-transform, immutable</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">body</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><p>spark 目前有两种内容类型：</p><ul><li><code>application/x-spark-sampler</code> - 抽样数据</li><li><code>application/x-spark-heap</code> - 堆数据</li></ul><p>你可以根据你想要取得的内容使用抽样器或堆模式来分析所获数据。</p><h3 id="protobuf-格式" tabindex="-1">Protobuf 格式 <a class="header-anchor" href="#protobuf-格式" aria-label="Permalink to &quot;Protobuf 格式&quot;">​</a></h3><p>从 spark“客户端”（即插件/模组本身）传输过来的原数据与 spark 报告浏览器是通过一种名为 <a href="https://protobuf.dev/" target="_blank" rel="noreferrer">protobuf</a>（又称 Protocol Buffers<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>）的格式进行编写的。若要正确判断数据，你就需要用到 protobuf 模式。</p><p>目前为止有两种模式（可以判断同种数据）：</p><ul><li>spark（Java）模式：<a href="https://github.com/lucko/spark/tree/master/spark-common/src/main/proto/spark" target="_blank" rel="noreferrer">https://github.com/lucko/spark/tree/master/spark-common/src/main/proto/spark</a></li><li>spark-viewer（TypeScript）模式：<a href="https://github.com/lucko/spark-viewer/tree/master/proto" target="_blank" rel="noreferrer">https://github.com/lucko/spark-viewer/tree/master/proto</a></li></ul><h3 id="示例代码" tabindex="-1">示例代码 <a class="header-anchor" href="#示例代码" aria-label="Permalink to &quot;示例代码&quot;">​</a></h3><p>这里有一个用 NodeJS 编写的简易 CLI，可以帮助你快速理解原数据的判断方式：<a href="https://github.com/lucko/spark2json" target="_blank" rel="noreferrer">https://github.com/lucko/spark2json</a></p><p>（其实这就是判断上述 JSON 格式的代码，😛）</p><h2 id="另见" tabindex="-1">另见 <a class="header-anchor" href="#另见" aria-label="Permalink to &quot;另见&quot;">​</a></h2><ul><li>有关 Protocol Buffers 的介绍：<a href="https://zhuanlan.zhihu.com/p/36554982" target="_blank" rel="noreferrer">https://zhuanlan.zhihu.com/p/36554982</a></li></ul><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>Protocol Buffers 是一种轻便高效的结构化数据存储格式，可以用于结构化数据序列化，很适合做数据存储或 RPC 数据交换格式。它可用于通讯协议、数据存储等领域的语言无关、平台无关、可扩展的序列化结构数据格式。 <a href="#fnref1" class="footnote-backref">↩︎</a></p></li></ol></section>`,32)]))}const u=a(p,[["render",n]]);export{d as __pageData,u as default};
