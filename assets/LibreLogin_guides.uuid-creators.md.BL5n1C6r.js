import{_ as a,c as o,o as r,b0 as d}from"./chunks/framework.w6NQj85O.js";const h=JSON.parse('{"title":"UUID 创建器","description":"","frontmatter":{},"headers":[],"relativePath":"LibreLogin/guides.uuid-creators.md","filePath":"LibreLogin/guides.uuid-creators.md"}'),t={name:"LibreLogin/guides.uuid-creators.md"};function i(c,e,n,s,p,l){return r(),o("div",null,e[0]||(e[0]=[d('<h1 id="uuid-创建器" tabindex="-1">UUID 创建器 <a class="header-anchor" href="#uuid-创建器" aria-label="Permalink to &quot;UUID 创建器&quot;">​</a></h1><p>LibreLogin 提供了三种 UUID 创建器，每个都有其优劣。</p><p><strong>这些设置仅对新玩家有效。</strong></p><h2 id="随机-random" tabindex="-1">随机（RANDOM） <a class="header-anchor" href="#随机-random" aria-label="Permalink to &quot;随机（RANDOM）&quot;">​</a></h2><p>这个模式非常直白，它会随机获取 UUID。</p><p>需要注意的是，如果你不迁移你的数据库，玩家很有可能会丢失数据。</p><h2 id="离线-cracked" tabindex="-1">离线（CRACKED） <a class="header-anchor" href="#离线-cracked" aria-label="Permalink to &quot;离线（CRACKED）&quot;">​</a></h2><p>这个模式获取的 UUID 与离线模式服务器的逻辑相同。</p><h3 id="劣势" tabindex="-1">劣势 <a class="header-anchor" href="#劣势" aria-label="Permalink to &quot;劣势&quot;">​</a></h3><p>让我们假设一个叫 <code>pepazdepavole</code> 的玩家首次进入服务器，他的 UUID 是 <code>f586c1d8-2314-3df5-bfc4-9ff22f132273</code>。这个玩家启用了自动登录并将他的名字改成了 <code>kyngs</code>。而 UUID 在此过程中不会产生变化。</p><p>现在有一个新的昵称为 <code>pepazdepavole</code> 的玩家首次进入服务器。数据库中没有这样的名称，逻辑上插件会尝试创建一个新用户。这样，玩家就会得到一个 <code>f586c1d8-2314-3df5-bfc4-9ff22f132273</code> 的 UUID。但是先前的 <code>kyngs</code> 已经拥有了相同的 UUID，所以 <code>pepazdepavole</code> 会被踢出，并要求使用 <code>kyngs</code> 这个名称登入服务器。</p><h4 id="太长不读" tabindex="-1">太长不读 <a class="header-anchor" href="#太长不读" aria-label="Permalink to &quot;太长不读&quot;">​</a></h4><p>玩家原有的名称会在他们使用新名称后保持占用。</p><h2 id="官方-mojang" tabindex="-1">官方（Mojang） <a class="header-anchor" href="#官方-mojang" aria-label="Permalink to &quot;官方（Mojang）&quot;">​</a></h2><p>该模式会先检查玩家是否存在于数据库中，若存在则使用正版 UUID，反之则使用离线 UUID。</p><p>劣势与离线模式相同。</p>',16)]))}const f=a(t,[["render",i]]);export{h as __pageData,f as default};
