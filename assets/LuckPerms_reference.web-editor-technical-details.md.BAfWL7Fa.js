import{_ as i,c as a,o as t,b0 as s}from"./chunks/framework.w6NQj85O.js";const l="/assets/webeditor-technical-1.ZtihIKLI.png",r="/assets/webeditor-technical-2.StKtH94f.png",n="/assets/webeditor-technical-3.Dnmou-KH.png",g=JSON.parse('{"title":"网页编辑器的技术细节","description":"","frontmatter":{},"headers":[],"relativePath":"LuckPerms/reference.web-editor-technical-details.md","filePath":"LuckPerms/reference.web-editor-technical-details.md"}'),o={name:"LuckPerms/reference.web-editor-technical-details.md"};function c(p,e,h,d,k,b){return t(),a("div",null,e[0]||(e[0]=[s(`<h1 id="网页编辑器的技术细节" tabindex="-1">网页编辑器的技术细节 <a class="header-anchor" href="#网页编辑器的技术细节" aria-label="Permalink to &quot;网页编辑器的技术细节&quot;">​</a></h1><p>LuckPerms 的网页编辑器是运行在浏览器中的特殊应用，允许服务器管理员通过网页界面编辑权限。</p><p>面向用户的文档可以访问<a href="./features.web-editor">网页编辑器</a>。本章节讲述的大部分为技术性信息。</p><h2 id="与服务器连接" tabindex="-1">与服务器连接 <a class="header-anchor" href="#与服务器连接" aria-label="Permalink to &quot;与服务器连接&quot;">​</a></h2><p>网页编辑器是由中心托管的（在 luckperms.net 上），但也需要能够与用户服务器上的 LuckPerms 插件进行通信。</p><p>网页编辑器本身无状态，但它会使用两个特殊服务与服务器交换信息。</p><ul><li><a href="https://github.com/lucko/bytebin" target="_blank" rel="noreferrer">bytebin</a> - 通过 HTTP 的 GET/POST 方法交换负载数据</li><li><a href="https://github.com/lucko/bytesocks" target="_blank" rel="noreferrer">bytesocks</a> - 通过 WebSockets 交换“实时”信息</li></ul><p>插件（在 Minecraft 服务器上运行的）和网页编辑器（在浏览器中运行的）都需要与“中间人”服务器交流，并使用它们与对方交换数据/指令。</p><h2 id="websocket-协议" tabindex="-1">WebSocket 协议 <a class="header-anchor" href="#websocket-协议" aria-label="Permalink to &quot;WebSocket 协议&quot;">​</a></h2><p>服务器和网页编辑器都会连接至由 bytesocks 服务（见上）提供的 WebSocket。它们会在这个频道内交换安全（秘密签署的）信息。</p><p>更多安全有关的信息可以在添加该功能的<a href="https://github.com/LuckPerms/LuckPerms/pull/3303" target="_blank" rel="noreferrer">合并请求</a>上查看。</p><h3 id="通信-包-格式" tabindex="-1">通信（包）格式 <a class="header-anchor" href="#通信-包-格式" aria-label="Permalink to &quot;通信（包）格式&quot;">​</a></h3><p>通信包以 JSON 格式编写。</p><div class="language-JSON vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">JSON</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    &quot;msg&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;string&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    &quot;signature&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;string&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>外部通信“frame”会显示上述两部分的内容。</p><ul><li><code>msg</code> 部分包含了 JSON 格式纯文本编码的包（未经加密）</li><li><code>signature</code> 部分包含了来自通信的 SHA256withRSA 签名信息，且为 base64 加密。</li></ul><h3 id="连接" tabindex="-1">连接 <a class="header-anchor" href="#连接" aria-label="Permalink to &quot;连接&quot;">​</a></h3><p>在内部会话创建（通过玩家在当前服务器输入命令 <code>/lp editor</code>）时，插件将会为此次会话产生一个新的 bytesocks 频道并立即加入。bytesocks 频道的 ID 与插件公钥包含在初始 bytebin 的数据负载中。玩家在打开网页编辑器链接时，bytebin 负载会以末尾的一段参数表示。</p><p>网页编辑器只接受频道中经过插件/服务器公钥签名的信息。</p><p>连接流程会在网页编辑器发送 <code>hello</code> 消息至频道（服务器应当已连接且“监听”频道）</p><p><code>hello</code> 信息包含：</p><ul><li>nonce - 简短的随机字符串，用于验证会话</li><li>sessionId - 网页编辑器打开的 bytebin ID</li><li>browser - 使用的操作系统/浏览器简单描述</li><li>publicKey - 编辑器公钥。用于确保从编辑器接收的后续信息未被篡改。</li></ul><p>在连接流程中，Minecraft 服务器（LuckPerms 插件）会确保：</p><ul><li>前一次会话中编辑器公钥可知</li><li>玩家已经通过命令信任编辑器。该过程使用 nonce 来确保他们在 &gt;1 次的连接中信任的设备相对应。</li></ul><p>服务器会返回一个 <code>hello-reply</code> 消息来告知编辑器下一步操作。</p><p><img src="`+l+'" alt="img"></p><p>在连接建立后，服务器只会接收以编辑器密钥签名的信息。</p><h3 id="ping" tabindex="-1">Ping <a class="header-anchor" href="#ping" aria-label="Permalink to &quot;Ping&quot;">​</a></h3><p>网页编辑器会间断发送 <code>ping</code> 消息，如果服务器还在监听，则会发回一个 <code>pong</code> 消息。</p><p>这个行为有两个目的：</p><ul><li>保持 WebSocket 频道活跃。一些中间 Web 代理会强制要求 keepalive，若消息一段时间内没有发送，则 socket 连接会被视作超时。</li><li>使得网页编辑器能够知晓服务器是否仍在监听，这样就可以使用 socket 来发送更新。</li></ul><p><img src="'+r+'" alt="img"></p><p>服务器也会使用 <code>pong</code> 消息来告知它已从 socket 断开连接。这样做的原因如下：</p><ul><li>Minecraft 服务器已关闭</li><li>创建会话的用户已离开服务器</li><li>连接超时</li><li>未知错误</li></ul><h3 id="请求修改" tabindex="-1">请求修改 <a class="header-anchor" href="#请求修改" aria-label="Permalink to &quot;请求修改&quot;">​</a></h3><p>在用户按下编辑器“应用（保存）”，这部分流程就会被触发。</p><p>网页编辑器会将变动上传至 bytebin 并收集负载 ID。它之后就会通过 socket 将 ID 传回服务器。</p><p>服务器会应用改动，然后上传 bytebin 中的刷新状态，并通过 socket 将负载 ID 传回。</p><p><img src="'+n+'" alt="img"></p>',39)]))}const m=i(o,[["render",c]]);export{g as __pageData,m as default};
